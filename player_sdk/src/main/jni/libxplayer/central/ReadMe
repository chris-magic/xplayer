-
-
video player have the following state machine:
    demux state machine ,
    audio decoder state machine,
    video decoder state machine ,


Each State Machine has its own state .

Such as Video Decoder State Machine has state :
            STATE_DECODER_START,
            STATE_DECODER_WAIT,
            STATE_DECODER_DECODING.


-
-
  Demux State Machine Rename to Central Engine State Machine .
    change media demux work be put into Central Engine State Machine Thread


-
-
 First Decode will happen until is_pkt_q_full(mediaFileHandle->start_playing_buffering_time) be performed.
 So before that ,you should not call decode function.

-
-

-
- Audio OutPut
-- opensl es
    任何一个 OpenSL ES 的对象，创建成功后，都进入 SL_OBJECT_STATE_UNREALIZED 状态，这种状态下，系统不会为它分配任何资源，直到调用 Realize 函数为止。
    Realize 后的对象，就会进入 SL_OBJECT_STATE_REALIZED 状态，这是一种“可用”的状态，只有在这种状态下，对象的各个功能和资源才能正常地访问。

    OpenSL ES major operations is interfaces ,such as: SLObjectItf ---Itf = Interface.

    - opensl es 遇到一个问题：
    - 所有逻辑走完 调用开始播放 SetPlayState(player->slPlay,  SL_PLAYSTATE_PLAYING ）,但是并没有调用回调函数。-----》最后解决方法： 在SetPlayState 之前调用下 Enqueue 方法，然后后面就可以调用了。



-- audio track

-
-
- GLSurfaceView.Renderer
    -- GLSurfaceView onPause;
            /**
            * Inform the view that the activity is paused. The owner of this view must
            * call this method when the activity is paused. Calling this method will
            * pause the rendering thread.
            * Must not be called before a renderer has been set.
            */
           public void onPause();

    -- GLSurfaceView onResume;
            /**
             * Inform the view that the activity is resumed. The owner of this view must
             * call this method when the activity is resumed. Calling this method will
             * recreate the OpenGL display and resume the rendering
             * thread.
             * Must not be called before a renderer has been set.
             */
            public void onResume();

    --  void queueEvent (Runnable r)
        Queue a runnable to be run on the GL rendering thread. This can be used to communicate with the Renderer on the rendering thread. Must not be called before a renderer has been set.
        r	Runnable: the runnable to be run on the GL rendering thread.

    -- GLSurfaceView.Render pause()
        this.setRenderMode(RENDERMODE_WHEN_DIRTY);  & queueEvent

-
-
- MediaPlayer start() function
    -- Change state to Buffering State.
    -- In Buffering state notify Java Layer buffering percent
    -- If Buffering percent become 100% , the central engine will change into PLAY_WAIT state ,then You can call java Layer play() function to start play.

- MediaPlayer play() function
    -- When Buffering percent 100% ,then audio decoder & video decoder thread begain to work.
    -- Notify GLSurfaceView Render Thread to change render mode from  RENDERMODE_WHEN_DIRTY to RENDERMODE_CONTINUOUSLY.

-
-
- Demux Thread change state from PLAYING to PLAY_END_OF_FILE .
        - this time the audio_packet_q video_packet_q audio_frame_q video_frame_q may be not null ,what should I do Under this condition.

-
-
- Pause().
    - GLSurfaceView setRenderMode(RENDERMODE_WHEN_DIRTY)
    - opensl es audio engine SetPlayState(bqPlayerPlay, SL_PLAYSTATE_PAUSED)
    -
    - audio & video decoder change_state(DECODE_STATE_WAIT) ,not decode media data.







-
- Memory
    adb shell dumpsys meminfo com.cmcm.v.cmplayersdk

-



-
-
- seek
    现在浏览器的seek ，完了后会再掉BaseVideoView的start（） 方法。

    需要把播放器的三个状态机的流程和工作再梳理下。。。。

    seek 时间点：
            1.播放中seek
            2.暂停时候seek
            3.缓冲中seek
            4.播放结束seek.

            5.起播之前的seek ，这个时候的seek时间点和其他阶段的seek 处理是不同的,这个时间点是在onPrepared 回调中判断是否需要进行seek 操作的。
                首次seek时机移到了onprepared回调中
            -



    seek 完成后 要调用player.start 方法播放起来。

-
- 播放过程中 Loading

    - video | audio packet queue is empty will call callback function to notify buffering [回调 el_pkt_q_empty_goto_buffering_cb 函数]
        is_empty(audio_pkt_q) && q_is_empty(video_pkt_q) .
        When Buffering , 要停止渲染 ，GLSurfaceView 设置render mode.

        -->

    -
    - buffering 有两种
        - 一种是原来按照picture queue 队列的数据为基准，就是解码后的视频队列数据，比如有15帧数据了，就可以开始播放，不到的话就开始buffering .
        - 还有一种就是按照packet queue ,这里是解码之前的数据为基准，这样的一个好处是解码前数据小 ,播放器占用内存低【这里存在一个假设是机器的解码性能是不存在问题的】，好像这种更合理些。。。。。。。。。


    - struct list_node *q_pop 函数
        // block until new code added
        if(q_head->empty_func)
        {
            el_mutex_unlock(q_head->mutex);
            q_head->empty_func(q_head->empty_parm);
            el_mutex_lock(q_head->mutex);
        }
    -

-
-
- 播放结束后 oncomplete ，音视频解码线程在堵塞等待数据，这里是有问题的，需要改成非阻塞。


--
- 用户pause 时机：   1.buffering 时候也可能会调pause ,stop ,close
                    2.prepared 之前也可能会调pause stop close



--
--
-   视频tab 页面，就一个播放器实例


--
--
-   view 中有一个播放器实例，是这样的，view对应的播放器可以多次销毁多次创建，但view 可以只创建一次，最后不需要的时候再销毁。


--
--
-   播放器实例销毁的时候，如果播放器不支持多实例，就要保证上一个实例销毁后，才能创建下一个播放器实例。同时要注意一个问题，就是opengl es的资源必须在GLSurfaceView Render 线程创建。

-
-
-
-
-   首次播放，this->mediaFileHandle->notify(MEDIA_BUFFERING_UPDATE ,100 ,100); 上层调 play 播放。



--
--
-   first_show_pic   这个回调并没有调起播放器播放，而是告诉上层播放器控制界面的变化。


--
-
-   触控面板
    每次通过触控面板进行播放器相关操作后都会执行 updatePausePlay  ,这个函数会对播放器的状态进行判断，从而显示相应的按钮。
